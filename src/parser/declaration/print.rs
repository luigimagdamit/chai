use crate::parser::expression::expr::DataType;
use crate::parser::parse_fn::expression;
use crate::parser::parser::Parser;
use crate::{common::flags::PARSE_DECLARATION_MODE, llvm::llvm_print::llvm_call_print_local, scanner::token::TokenType};

use super::variable::LlvmTempRegister;


pub enum LlvmCallPrint {
    String(u32) //register value
}
impl LlvmCallPrint {
    pub fn call_print(&self) -> String {
        match self {
            LlvmCallPrint::String(register) => {
                format!("call i32 (i8*, ...) @printf(i8* %{})\n; Auto generated by LlvmCallPrint (print.rs)", register)
            }
        }
    }
}
pub fn print_statement(parser: &mut Parser) {

    expression(parser);
    if let Some(expr) = parser.constant_stack.pop() {
        let value = expr.unwrap_or_else(||panic!("Tried evaluation an expression in print_statement, but opened an empty Expr"));
        let print_val = &value.left;
        
        match &value.data_type {
            DataType::Boolean(_) => {
                llvm_print_i1_local(parser.expr_count, print_val);
            }
            DataType::Integer(_) => {
                let codegen = llvm_print_i32_local(parser.expr_count, print_val);
                parser.emit_instruction(&codegen);

            },
            DataType::String(str_value) => {
                // with raw_str, lookup in the table
                let str_lookup = parser.string_table.get(str_value).clone();
                if let Some(lookup_result) = str_lookup {
                    
                    // look up the string value within the Expr, do lookup, then get the constant index
                    // within StringEntry in order to retrieve appropariate value in LLVM Constants

                    // %2 = getelementptr inbounds [13 x i8], [13 x i8]* @str0, i32 0, i32 0
                    let tmp_register = LlvmTempRegister::StaticString(parser.expr_count);
                    let load_string_codegen = tmp_register.new_register(lookup_result);
                    println!("{}", load_string_codegen);
                    parser.emit_instruction(&load_string_codegen);

                    let print_inst = LlvmCallPrint::String(parser.expr_count).call_print();
                    println!("{}", print_inst);
                    parser.emit_instruction(&print_inst);

                    parser.expr_count += 1;


                }
                // if value.right != "<__var_string__>" {
                    
                //     parser.compilation += &llvm_print_str_local(parser.expr_count, print_val);
                //     // does not place anything on the stack...
                //     //parser.expr_count += 1;
                // } else {
                    
                //     let codegen = format!("call i32 (i8*, ...) @printf(i8* {})", print_val);
                //     if PARSE_DECLARATION_MODE { println!("{}", codegen)}
                //     parser.emit_instruction(&codegen);
                //     //parser.expr_count += 1;
                // }
                
            }
        }
    }
    
    parser.expr_count += 1;
    parser.consume(TokenType::Semicolon, "Expect semicolon after value");
}

fn llvm_print_i32_local(reg_name: u32, value: &String) -> String{
    let c1 = format!("%{} = add {}, 0\n", reg_name , value);
    println!("{}", c1);
    let c2 = llvm_call_print_local(reg_name, "i32");
    println!("{}", c2);
    c1 + &c2
}
fn llvm_print_str_local(reg_name: u32, value: &String) -> String {
    let c1 = format!("\n%{} = {}\n", reg_name, value);
    let c2 = format!("call i32 (i8*, ...) @printf(i8* %{})\n", reg_name);
    let res = c1 + &c2;

    if PARSE_DECLARATION_MODE { println!("{}", &res)}
    res
}
fn llvm_print_i1_local(reg_name: u32, value: &String) {
    println!("%{} = add {}, 0", reg_name , value);
    llvm_call_print_local(reg_name, "i1");
}