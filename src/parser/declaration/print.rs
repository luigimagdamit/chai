use crate::parser::expression::expr::{DataType, Expr};
use crate::parser::parse_fn::expression;
use crate::parser::parser::Parser;
use crate::{common::flags::PARSE_DECLARATION_MODE, llvm::llvm_print::llvm_call_print_local, scanner::token::TokenType};

use super::variable::LlvmTempRegister;


// all printed items should pass through this!
pub enum LlvmCallPrint {
    String(u32), //register value
    Integer(u32),
}
impl LlvmCallPrint {
    pub fn call_print(&self) -> String {
        match self {
            LlvmCallPrint::String(register) => {
                format!("\tcall i32 (i8*, ...) @printf(i8* %{})\t\t\t\t\t\t\t\t\t\t\t; Auto generated by LlvmCallPrint (print.rs)\n", register)
            }
            Self::Integer(register) => panic!()
        }
    }
    pub fn print_i32(&self, int_expr: &Expr) -> String {
        match self {
            Self::Integer(register) => {
                let c1 = format!("\t%{} = add {}, 0", register , int_expr.left);
                println!("{}", c1);
                let c2 = llvm_call_print_local(register.clone(), "i32");
                println!("{}", c2);
                c1 + &c2 + "; Auto generated by LlvmCallPrint (i 32)(print.rs)"
            }
            _ => panic!("Not a i32")
        }
    }
    pub fn print_i1(&self, int_expr: &Expr) -> String {
        match self {
            Self::Integer(register) => {
                let c1 = format!("\t%{} = add {}, 0\n", register , int_expr.left);
                println!("{}", c1);
                let c2 = llvm_call_print_local(register.clone(), "i1");
                println!("{}", c2);
                c1 + &c2 + "; Auto generated by LlvmCallPrint (i1) (print.rs)"
            }
            _ => panic!("Not a i32")
        }
    }
}
pub fn print_statement(parser: &mut Parser) {
    expression(parser);
    if let Some(expr) = parser.constant_stack.pop() {
        let value = expr.unwrap_or_else(||panic!("Tried evaluation an expression in print_statement, but opened an empty Expr"));
        match &value.data_type {
            DataType::Boolean(_) => {
                let codegen = LlvmCallPrint::Integer(parser.expr_count).print_i1(&value) + "\t\t\t\t; Printing a bool type (print.rs)";
                parser.emit_instruction(&codegen);
            }
            DataType::Integer(_) => {
                // pass tmp register value and the Expr item itself.
                let codegen = LlvmCallPrint::Integer(parser.expr_count).print_i32(&value) + "\t\t\t\t; Printing a int type (print.rs)";
                parser.emit_instruction(&codegen);
            },
            DataType::String(str_value) => {
                // with raw_str, lookup in the table
                let str_lookup = parser.string_table.get(str_value).clone();
                if let Some(lookup_result) = str_lookup {
                    
                    // look up the string value within the Expr, do lookup, then get the constant index
                    // within StringEntry in order to retrieve appropariate value in LLVM Constants

                    // %2 = getelementptr inbounds [13 x i8], [13 x i8]* @str0, i32 0, i32 0
                    let tmp_register = LlvmTempRegister::StaticString(parser.expr_count);
                    let load_string_codegen = tmp_register.new_register(lookup_result);
                    println!("{}\t\t\t\t; Printing a string type (print.rs)", load_string_codegen);
                    parser.emit_instruction(&load_string_codegen);

                    let print_inst = LlvmCallPrint::String(parser.expr_count).call_print();
                    println!("{}", print_inst);
                    parser.emit_instruction(&print_inst);

                    parser.expr_count += 1;


                }
                
            }
        }
    }
    
    parser.expr_count += 1;
    parser.consume(TokenType::Semicolon, "Expect semicolon after value");
}

